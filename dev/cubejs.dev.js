/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./test/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/adapters/elasticsearch.js":
/*!***************************************!*\
  !*** ./src/adapters/elasticsearch.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// @ts-check\n\n/* jshint latedef: nofunc */\n// converte o cubo de es para cubejs\n\nfunction getLevel(def){\n    let i;\n    let j = 0;\n    let q = 0;\n\n    for (i in def){\n        if (def[i].type != 'measure') q++;\n        else j = 1;\n    }\n\n    return q + j;\n}\nfunction transform(definition, agg){\n    let i, cube;\n    let mapCols = {};\n    let mapRows = {};\n    let x = 0;\n    let y = 0;\n    \n    cube = {\n        cols:{\n            levels: getLevel(definition.cols)\n        },\n        rows:{\n            levels: getLevel(definition.rows)\n        },\n        data:[]\n    };\n    // @ts-ignore\n    cube.data.collength = 0;\n    \n    // define se a raiz é linha ou coluna\n    for (i in agg){\n        (definition.cols[i] ? processColBucket : processRowBucket)(i, agg[i], '', cube.cols, cube.rows);\n        break;\n    }\n    \n    function processColBucket(bucketKey, bucket, parentKey, parentObjCol, parentObjRow){\n        var i, j, k, b, e, buckets, child;\n        \n        parentObjCol.children = parentObjCol.children || [];\n        buckets = bucket.buckets;\n        \n        for (i = 0; i < buckets.length; i++){\n            e = false;\n            b = buckets[i];\n            k = parentKey + b.key;\n            child = createColItem(parentObjCol.children, {id:k, label:b.key_as_string || b.key, category:b.key, dimension:bucketKey});\n            \n            for (j in b){\n                if (definition.cols[j]){\n                    e = true;\n                    if (definition.cols[j].type == 'measure' || !b[j].buckets){\n                        // métrica de coluna\n                        processMeasureBucketCol(j, b[j], child, mapCols[k].x);\n                    } else {\n                        // dimensão de coluna\n                        processColBucket(j, b[j], k + '$', child, parentObjRow);\n                    }\n                } else if (definition.rows[j]){\n                    e = true;\n                    if (definition.rows[j].type == 'measure' || !b[j].buckets){\n                        // métrica de linha\n                        processMeasureBucketRow(j, b[j], parentObjRow, mapCols[k].x);\n                    } else {\n                        // dimensão de linha\n                        processRowBucket(j, b[j], '', child, parentObjRow);\n                    }\n                }\n            }\n            \n            if (!e){\n                // métrica no data\n                processDataBucket(b, mapCols[k].x, mapRows[parentObjRow.id] ? mapRows[parentObjRow.id].y : 0);\n            }\n        }\n    }\n    function processRowBucket(bucketKey, bucket, parentKey, parentObjCol, parentObjRow){\n        var i, j, k, b, e, buckets, child;\n        \n        parentObjRow.children = parentObjRow.children || [];\n        buckets = bucket.buckets;\n        \n        for (i = 0; i < buckets.length; i++){\n            e = false;\n            b = buckets[i];\n            k = parentKey + b.key;\n            child = createRowItem(parentObjRow.children, {id:k, label:b.key_as_string || b.key, category:b.key, dimension:bucketKey});\n            \n            for (j in b){\n                if (definition.cols[j]){\n                    e = true;\n                    if (definition.cols[j].type == 'measure' || !b[j].buckets){\n                        // métrica de coluna\n                        processMeasureBucketCol(j, b[j], parentObjCol, mapRows[k].y);\n                    } else {\n                        // dimensão de coluna\n                        processColBucket(j, b[j], '', parentObjCol, child);\n                    }\n                } else if (definition.rows[j]){\n                    e = true;\n                    if (definition.rows[j].type == 'measure' || !b[j].buckets){\n                        // métrica de linha\n                        processMeasureBucketRow(j, b[j], child, mapCols[parentObjCol.id].x);\n                    } else {\n                        // dimensão de linha\n                        processRowBucket(j, b[j], k + '$', parentObjCol, child);\n                    }\n                }\n            }\n            \n            if (!e){\n                // métrica no data\n                processDataBucket(b, mapCols[parentObjCol.id] ? mapCols[parentObjCol.id].x : 0, mapRows[k].y);\n            }\n        }\n    }\n    function processMeasureBucketCol(bucketKey, bucket, parentObj, y){\n        let x, k;\n        \n        parentObj.children = parentObj.children || [];\n        k = (parentObj.id ? parentObj.id + '$' : '') + bucketKey;\n        createColItem(parentObj.children, {id:k, label:bucketKey, measure:bucketKey});\n        \n        x = mapCols[k].x;\n        \n        cube.data[y] = cube.data[y] || [];\n        cube.data[y][x] = {value: (bucket.value === undefined ? bucket : bucket.value)};\n        \n        // if (cube.data.collength < cube.data[y].length) cube.data.collength = cube.data[y].length;\n    }\n    function processMeasureBucketRow(bucketKey, bucket, parentObj, x){\n        let y, k;\n        \n        parentObj.children = parentObj.children || [];\n        k = (parentObj.id ? parentObj.id + '$' : '') + bucketKey;\n        createRowItem(parentObj.children, {id:k, label:bucketKey, measure:bucketKey});\n        \n        y = mapRows[k].y;\n        \n        cube.data[y] = cube.data[y] || [];\n        cube.data[y][x] = {value:bucket.value || bucket};\n        \n        // if (cube.data.collength < cube.data[y].length) cube.data.collength = cube.data[y].length;\n    }\n    function processDataBucket(bucket, x, y){\n        cube.data[y] = cube.data[y] || [];\n        cube.data[y][x] = {value:bucket.doc_count};\n        // if (cube.data.collength < cube.data[y].length) cube.data.collength = cube.data[y].length;\n    }\n    function createColItem(children, item){\n        if (!mapCols[item.id]) {\n            children.push(item);\n            if (children.length > 1)x++;\n            mapCols[item.id] = {\n                item: item,\n                x:x\n            };\n            // cube.data.collength = x;\n        }\n        \n        return mapCols[item.id].item;\n    }\n    function createRowItem(children, item){\n        if (!mapRows[item.id]) {\n            children.push(item);\n            if (children.length > 1)y++;\n            mapRows[item.id] = {\n                item: item,\n                y:y\n            };                \n        }\n        \n        return mapRows[item.id].item;\n    }\n    // console.log(mapCols); console.log(mapRows);\n    return cube;\n}\n\n/**\n * Transforma dados de resposta do elasticsearch para um formato de matriz\n * @param cubejs CubeJS\n * @param data Object\n */\n// export default function ElasticAdapter (cubejs, data) {\n//     if (data && !data.__es__) {\n//         data = transform(cubejs.getDefinition(), data.aggregations);\n//         data.__es__ = true;\n//     }\n    \n//     return data;\n// }\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    response(cubejs, data){\n        let o = {\n            levels: 1,\n            children:[\n                {\n                    id: 'doc_count',\n                    label: 'count',\n                    measure: 'doc_count'\n                }\n            ]\n        };\n\n        if (data && !data.__es__) {\n            data = transform(cubejs.getDefinition(), data.aggregations);\n\n            if (data.cols.levels == 0){\n                data.cols = o\n            } else if (data.rows.levels == 0){\n                data.rows = o\n            }\n\n            data.__es__ = true;\n        }\n        \n        return data;\n    },\n\n    // prepara o json de envio\n    request(cubejs, options){\n        let i, k, d, p, v, o, o1, o2, o3;\n        let a = [];\n        let b = [];\n        let c = [];\n        let json = {size:0};\n        \n        // _cols = options.cols;\n        // _rows = options.rows;\n        \n        // coloca as variáveis na ordem linhas, colunas, métricas\n        for (i = 0; i < options.cols.length; i++){\n            a.push(options.cols[i]);\n        }\n        for (i = 0; i < options.rows.length; i++){\n            a.push(options.rows[i]);\n        }\n        \n        function itemAggs(aggsObj, name){\n            let p, v, k, d, o2, o3, o4;\n                \n            p = name.split('.');\n            v = name.replace('.', '_');\n            k = p[0];\n            d = options.dimensions[k];\n            o2 = aggsObj.aggs = {};\n            o3 = o2[v] = {};\n                \n            switch (d.type){\n            case 'date':\n                o4 = o3['date_histogram'] = {\n                    field: k\n                };\n                switch (p[1]){\n                case 'year':\n                    o4['interval'] = 'year';\n                    o4['format'] = 'yyy';\n                    break;\n                }\n                break;\n\n            default:\n                o3['terms'] = {\n                    field: a[i]\n                };\n                break;\n            }\n            \n            return o3;\n        }\n        \n        // cria o json ES a ser enviado\n        o1 = json;            \n        for (i = 0; i < a.length; i++){\n            k = a[i].split('.')[0];\n            d = options.dimensions[k];\n            \n            if (d){\n                if (d.nested){ // nested fica no final\n                    b.push(a[i]);\n                } else {\n                    o1 = itemAggs(o1, a[i]);\n                }\n            } else {\n                d = options.measures[k];\n                if (d){ // métricas ficam no final\n                    c.push(k);\n                }\n            }\n        }\n        \n        // adiciona o nested\n        for (i = 0; i < b.length; i++){\n            p = b[i].split('.');\n            v = b[i].replace('.', '_');\n            k = p[0];\n            d = options.dimensions[k];\n            o2 = o1['aggs'] = {};\n            o3 = o2[v] = {};\n            \n            // tipos nested devem ficar no final\n            o2[v] = o = {\n                nested: {\n                    path: k\n                },\n                aggs:{}\n            };\n            o3 = o.aggs[v] = {};\n            o3['terms'] = {\n                field: b[i]\n            };\n        }\n        \n        // adiciona as métricas\n        if (c.length > 0){\n            // o2 = o1.aggs = {};\n            // for (i = 0; i < c.length; i++){\n            //     d = vars[c[i]];\n            //     o3 = o2[c[i]] = {};\n            //     o3[d.aggs] = {\n            //         field: c[i]\n            //     };\n            // }\n        }\n        \n        return {\n            url : '/_search',\n            type: 'POST',\n            dataType: 'json',\n            data: JSON.stringify(json)\n        };        \n    }\n});\n\n\n//# sourceURL=webpack:///./src/adapters/elasticsearch.js?");

/***/ }),

/***/ "./src/cubejs.js":
/*!***********************!*\
  !*** ./src/cubejs.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// @ts-check\n\n/* eslint no-new-func:off */\n/* jshint evil:true */\n\nlet functions = {};\nlet operations = {};\nlet noop = function(){};\n\nconst DEFAULT_OPERATION_OPTIONS = {\n    priority: 100,\n    create: noop,\n    init: noop\n}\n\nconst DEFAUL_FORMAT = {\n    precision: 2,\n    prefix   : '',\n    suffix   : '',\n    decimal  : '.',\n    thousand : ','\n};\n\nclass CubeJS{\n    constructor(options){\n        this._format = Object.assign({}, DEFAUL_FORMAT, options.format || {});\n\n        this._operations = [];\n        this._mapRows = {};\n        this._mapCols = {};\n        this._adapter = options.dataAdapter;\n        this._definition = options.definition;\n    }\n\n    getDefinition(){\n        return this._definition;\n    }\n\n    setData(data){\n        if (data && !data.__processed__) {\n            this._data = this._adapter ? this._adapter.response(this, data) : data;\n            \n            // this._data.collength = 0\n            // this._data.cols = this._data.cols || {children:[]}\n            // this._data.rows = this._data.rows || {children:[]}\n            // this._data.rows.levels = this._data.rows.levels || 1\n            // this._data.cols.levels = this._data.cols.levels || 1\n\n            this._initOperations();\n            this._createMatrix();\n            \n            data.__processed__ = true;\n        }\n\n        return this;\n    }\n\n    getData(){\n        return this._data\n    }\n\n    getMatrix(){\n        return this._matrix //._data.data;\n    }\n\n    addOperation(id, name, options) {\n        let op, fn;\n        let o = operations[name];\n        let type = typeof (options.expression);\n        \n        if (o){\n            if (type == 'function'){\n                fn = options.expression;\n            } else {\n                fn = options.expression ? this._compilerExpression(options.expression) : function(){ return null; };\n            }\n\n            op = {\n                id       : id,\n                type     : name,\n                priority : o.priority,\n                position : options.position || 'after', /* after ou before */\n                reference: options.reference,\n                label    : options.label || id,\n                value    : fn,\n                custom   : type === 'function',\n                summary  : options.summary\n            };\n            this._operations.push(op);\n            o.create(this, op);\n        } else {\n            console.error('Operation \"' + name + '\" not found.');\n        }\n        \n        return this;\n    }\n\n    removeOperation(id){\n        let i;\n        \n        for (i = 0; i < this._operations.length; i++){\n            if (this._operations[i].id === id){\n                this._operations.splice(i, 1);\n                break;\n            }\n        }\n        \n        return this;\n    }\n\n    _compilerExpression(exp){\n        let i, r, c;\n\n        // $CELL(1,2) = $CELL.call($s, 1, 2)\n        \n        for (i in functions) {\n            r = new RegExp(`\\\\${i}\\\\s*\\\\(`, 'g');\n            c = `$f.${i}.call(this,`;\n\n            exp = exp.replace(r, c);\n        }\n        \n        return Function('$r', '$c', '$f', 'return ' + exp);\n    }\n    \n    _createMatrix(){\n        let i, j, r, c, op, a, row, cell\n        let mt = this._matrix = []\n        let cube = this._data\n        let ops = this._operations\n        let mapCols = this._mapCols\n        let mapRows = this._mapRows\n        let dataColsLength = 0 // cube.data.collength;\n        let dataRowsLength = cube.data.length\n        let calculatedCells = {}\n        \n        // títulos de colunas\n        let createColCell = (obj, row, col) => {\n            let i;\n            \n            if (!mt[row]) mt[row] = [];\n            mt[row][col] = obj;\n            \n            if (obj.calculated){\n                for (i = 0; i < dataRowsLength; i++){\n                    cube.data[i].splice(col - cube.rows.levels, 0, null);\n                }\n                dataColsLength++;\n                calculatedCells[obj.id] = obj;\n            }\n            \n            if (obj.children){\n                for (i = 0; i < obj.children.length; i++){\n                    col = createColCell(obj.children[i], row + 1, col);\n                }\n                return col;\n    \n            } else {\n                mapCols[obj.id] = col;\n            }\n            \n            return col + 1;\n        };\n        \n        // títulos de linhas\n        let createRowCell = (obj, row, col) => {\n            var i;\n            \n            if (!mt[row]) { \n                mt[row] = [];\n            }\n            \n            mt[row][col] = obj;\n            \n            if (obj.calculated){\n                cube.data.splice(row - cube.cols.levels, 0, []);\n                dataRowsLength++;\n                calculatedCells[obj.id] = obj;\n            }\n            \n            if (obj.children){\n                for (i = 0; i < obj.children.length; i++){\n                    row = createRowCell(obj.children[i], row, col + 1);\n                }\n                return row;\n    \n            } else {\n                mapRows[obj.id] = row;\n            }\n            \n            return row + 1;\n        };\n        \n        // células calculados\n        let caculatedRowValues = (obj) => {\n            let i, j, r, c, v;\n            let row = mapRows[obj.id];\n    \n            r = mt[row];\n            for (i = 0; i < dataColsLength; i++){\n                j = row - cube.cols.levels;\n                v = obj.value.apply(this, [j, i, functions]);\n                c = i + cube.rows.levels;\n                \n                r[c] = {\n                    value  : v,\n                    calc   : 'row',\n                    summary: obj.summary\n                };\n                \n                // atualiza cube.data\n                cube.data[j][i] = {value:v, calc:'row'};\n                this._formatValue(r[c]);\n            }\n        };\n\n        let caculatedColValues = (obj) => {\n            let i, j, r, v;\n            let col = mapCols[obj.id];\n            \n            for (i = 0; i < dataRowsLength; i++){\n                r = cube.cols.levels + i;\n                \n                if (mt[r]){\n                    j = col - cube.rows.levels;\n                    v = obj.value.apply(this, [i, j, functions]);\n                    \n                    mt[r][col] = {\n                        value    : v,\n                        calc     : 'col',\n                        summary: obj.summary\n                    };\n                \n                    // atualiza cube.data\n                    cube.data[i][j] = {value:v, calc:'col'};\n                    this._formatValue(mt[r][col]);\n                }\n            }\n        };\n\n        // calcula collength e dataColsLength\n        cube.data.forEach(arr => {\n            if (arr.length > dataColsLength){\n                dataColsLength = cube.data.collength = arr.length;\n            }\n        });\n\n        c = cube.rows.levels;\n        for (i = 0; i < cube.cols.children.length; i++){\n            c = createColCell(cube.cols.children[i], 0, c);\n        }\n\n        r = cube.cols.levels;\n        for (i = 0; i < cube.rows.children.length; i++){\n            r = createRowCell(cube.rows.children[i], r, 0);\n        }\n        \n        // dados\n        for (r = 0; r < cube.data.length; r++){\n            row = cube.data[r];\n            i = r + cube.cols.levels;\n            \n            for (c = 0; c < row.length; c++){\n                cell = row[c];\n                j = c + cube.rows.levels;\n                if (mt[i]) mt[i][j] = row[c];\n                this._formatValue(cell);\n            }\n        }\n        \n        // calcula os valores das operações de linhas e colunas\n        for (i = 0; i < ops.length; i++){\n            op = ops[i];\n            a = calculatedCells[op.id];\n            if (a){\n                if (a.type === 'calculatedRow'){\n                    caculatedRowValues(a);\n                } else if (a.type === 'calculatedCol'){\n                    caculatedColValues(a);\n                }\n            }\n        }\n        \n        // @ts-ignore\n        mt.colsLength = dataColsLength + cube.rows.levels;\n        // @ts-ignore\n        mt.rowsLength = dataRowsLength + cube.cols.levels;\n        \n        return mt;\n    }\n    \n    _initOperations(){\n        let i, op;\n        \n        // ordena as operações por prioridade\n        this._operations.sort(this._sortByPriority);\n        \n        for (i = 0; i < this._operations.length; i++){\n            op = this._operations[i];\n            operations[op.type].init(this, op);\n        }        \n    }\n    \n    _sortByPriority(a, b) {\n        if (a.priority === b.priority){\n            return 0;\n        }\n    \n        if (a.priority > b.priority){\n            return -1;\n        }\n    \n        return 1;\n    }\n\n    /**\n     * @private\n     * @param {*} cell \n     */\n    _formatValue(cell){\n        let v, a;\n    \n        if (cell && typeof (cell.value) == 'number'){\n            v = cell.value.toFixed(this._format.precision);\n            a = v.split('.');\n            v = a[0].replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, '$1' + this._format.thousand) + (a[1] ? this._format.decimal + a[1] : '');\n            cell.label = this._format.prefix + v + this._format.suffix;\n        }\n    }\n\n    static createFunction(name, fn) {\n        functions[name] = fn;\n        return fn;\n    }\n    static createOperation(name, def = {}){\n        let d = {}\n\n        Object.assign(d, DEFAULT_OPERATION_OPTIONS, def)\n        operations[name] = d;\n\n        return this;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CubeJS);\n\n\n//# sourceURL=webpack:///./src/cubejs.js?");

/***/ }),

/***/ "./src/functions.js":
/*!**************************!*\
  !*** ./src/functions.js ***!
  \**************************/
/*! exports provided: CELL, SUMMARY_ROW, MEASURE_ROW, PERCENT_ROW */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CELL\", function() { return CELL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SUMMARY_ROW\", function() { return SUMMARY_ROW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MEASURE_ROW\", function() { return MEASURE_ROW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PERCENT_ROW\", function() { return PERCENT_ROW; });\n/* harmony import */ var _cubejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubejs */ \"./src/cubejs.js\");\n// @ts-check\n\n\n\nconst CELL = _cubejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createFunction('$CELL', function(r, c){\n    let ro, co;\n    let mc = this._mapCols;\n    let mr = this._mapRows;\n    let cube = this._data;\n    \n    if (typeof (r) == 'string'){\n        r = mr[r] - cube.cols.levels;\n    }\n    if (typeof (c) == 'string'){\n        c = mc[c] - cube.rows.levels;\n    }\n\n    ro = cube.data[r];\n    co = ro ? ro[c] : null;\n\n    return co ? co.value : null;\n});\n\nconst SUMMARY_ROW = _cubejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createFunction('SUMMARY_ROW', function(r, c){\n    let i, ce\n    let s = 0\n    let q = 0\n\n    if (this.$CACHE_ROWSUM[r] == undefined){\n        this.$CACHE_ROWSUM[r] = {}\n        this.$CACHE_ROW_MEASURE[r] = {}\n        this.$CACHE_ROW_PERCENT[r] = {}\n    }\n\n    if (this.$CACHE_ROWSUM[r][c] == undefined){    \n        for (i = this._cube.cols.levels; i < r; i++){\n            ce = this.MT[i][c]\n            if (ce){\n                s += ce.value\n                q++\n            }\n        }\n\n        this.$CACHE_ROWSUM[r][c] = s\n        this.$CACHE_ROW_MEASURE[r][c] = s / q\n        this.$CACHE_ROW_PERCENT[r][c] = 'TODO'\n    }\n\n    return this.$CACHE_ROWSUM[r][c]\n});\n\nconst MEASURE_ROW = _cubejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createFunction('MEASURE_ROW', function(r, c){\n    this.SUMMARY_ROW(r, c);\n    return this.$CACHE_ROW_MEASURE[r][c];\n});\n\nconst PERCENT_ROW = _cubejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createFunction('PERCENT_ROW', function(r, c){\n    this.SUMMARY_ROW(r, c);\n    return this.$CACHE_ROW_PERCENT[r][c];\n});\n\n\n\n\n//# sourceURL=webpack:///./src/functions.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _cubejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubejs */ \"./src/cubejs.js\");\n/* harmony import */ var _operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./operations */ \"./src/operations.js\");\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions */ \"./src/functions.js\");\n// @ts-check\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_cubejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/operations.js":
/*!***************************!*\
  !*** ./src/operations.js ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _cubejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cubejs */ \"./src/cubejs.js\");\n// @ts-check\n\n\n\nfunction doCalcOperation(op, obj, parent, index){\n    let i, o;\n\n    if (obj.id == op.reference) {\n\n        o = {\n            calculated: true, \n            type: op.type, \n            id: op.id, \n            label: op.label, \n            position: op.position, \n            value:op.value\n        };\n\n        if (op.position == 'after'){ // after\n            parent.splice(++index, 0, o);\n        } else { // before\n            parent.splice(index++, 0, o);\n        }\n    }\n\n    if (obj.children){\n        for (i = 0; i < obj.children.length; i++){\n            i = doCalcOperation(op, obj.children[i], obj.children, i);\n        }\n    }\n\n    return index;\n}\n\n// context = CubeJS instance\nfunction doTotalCol(y, x){\n    let i, r, c;\n    let s = 0;\n    let m = this._data.data;\n    \n    r = m[y];\n    \n    for (i = 0; i < r.length; i++){\n        c = r[i];\n        if (c && x !== i) s += c.value;\n    }\n    \n    return s;\n}\n\n// context = CubeJS instance\nfunction doTotalRow(y, x){\n    let i, c;\n    let s = 0;\n    let m = this._data.data;\n    \n    for (i = 0; i < m.length; i++){\n        c = m[i][x];\n        if (c && y != i) s += c.value;\n    }\n    \n    return s;\n}\n\n_cubejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n    .createOperation('calculatedRow', {\n        init(instance, op){\n            let i;\n            let data = instance.getData();\n\n            for (i = 0; i < data.rows.children.length; i++){\n                i = doCalcOperation(op, data.rows.children[i], data.rows.children, i);\n            }\n        }\n    })\n    .createOperation('calculatedCol', {\n        init(cubeJs, op){\n            let i;\n            let data = cubeJs.getData();\n\n            for (i = 0; i < data.cols.children.length; i++){\n                i = doCalcOperation(op, data.cols.children[i], data.cols.children, i);\n            }\n        }\n    })\n    .createOperation('totalCol', {\n        priority: 20, // quanto maior a prioridade será executado mais para o final\n        init: function(cubeJs, op){\n            let o;\n            let data = cubeJs.getData()\n            let definition = cubeJs.getDefinition()\n            \n            if (definition.cols && data.cols){\n                o = {\n                    calculated: true, \n                    type: 'calculatedCol', \n                    id: op.id, \n                    label: op.label, \n                    position: op.position, \n                    value: doTotalCol, \n                    summary: true\n                };\n    \n                data.cols.children.push(o);\n            }\n        }\n    })\n    .createOperation('totalRow', {\n        priority: 20,\n        init(cubeJs, op){\n            let o;\n            let data = cubeJs.getData();\n            \n            o = {\n                calculated: true, \n                type: 'calculatedRow', \n                id: op.id, \n                label: op.label, \n                position: op.position, \n                value: doTotalRow, \n                summary: true\n            };\n\n            data.rows.children.push(o);\n        }\n    });\n\n\n//# sourceURL=webpack:///./src/operations.js?");

/***/ }),

/***/ "./src/plugins/table.js":
/*!******************************!*\
  !*** ./src/plugins/table.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return table; });\n// @ts-check\nfunction toHTML(cubeJs, options){\n    let r, c, row, html;\n    let cube = cubeJs.getData();\n    let matrix = cubeJs.getMatrix();\n    \n    function createHTMLCell(r, c, obj){\n        let cls;\n        let v = '';\n            \n        if (r > cube.cols.levels - 1){\n            if (c > cube.rows.levels - 1){\n                cls = 'cell value'; // dados\n            } else {\n                cls = 'cell label label-row'; // título de linhas\n            }\n        } else {\n            if (c > cube.rows.levels - 1){\n                cls = 'cell label label-col'; // título de colunas\n            } else {\n                cls = 'cell'; // canto\n            }\n        }\n        \n        if (obj){\n            cls += obj.calculated ? ' calc-' + obj.calc + ' label-calc' : '';\n            cls += obj.calc ? ' calc-' + obj.calc + ' value-calc' : '';\n        }\n        \n        v = (obj ? obj.label || obj.value || obj.dimension || obj.measure || null : null);\n        \n        return '<td class=\"' + cls + '\">' + (v === null || v === undefined ? '' : v) + '</td>';\n    }\n    \n    html = `<table class=\"table ${options.className}\" border=\"1\" cellpadding=\"3\" cellspacing=\"0\">`;\n    console.log(matrix)\n    if (matrix){\n        for (r = 0; r < matrix.rowsLength; r++){\n            row = matrix[r];\n            html += '<tr>';\n            for (c = 0; c < matrix.colsLength; c++){\n                html += createHTMLCell(r, c, row[c]);\n            }\n            html += '</tr>';\n        }\n    } else {\n        html += '<tr><td style=\"padding:20px\">no data</td></tr>'\n    }\n    html += '</table>';\n    \n    return ('<pre>' + html + '</pre>');\n}\n\nfunction table(cubeJS, element, options = {}){\n    element.innerHTML = toHTML(cubeJS, options)\n    return element\n}\n\n\n//# sourceURL=webpack:///./src/plugins/table.js?");

/***/ }),

/***/ "./test/data2.js":
/*!***********************!*\
  !*** ./test/data2.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst definition = {\n    rows: {\n        'combustivel': {type:'dimension'}\n    }\n}\n\nconst data = {\n    rows: {\n        level:1,\n        children: [\n            {\n                catergory: 'gasolina',\n                dimension: 'combustivel'\n            },\n            {\n                catergory: 'diesel',\n                dimension: 'combustivel'\n            },\n            {\n                catergory: 'etanol',\n                dimension: 'combustivel'\n            }\n        ]\n    },\n    cols: {\n        level:1,\n        children:[\n            {\n                id: 'doc_count',\n                label: 'count',\n                measure: 'doc_count'\n            }\n        ]\n    },\n    data: [\n        [\n            {value:1000,  id:'0', category:0, dimension:'combustivel'},\n            {value:15000, id:'0', category:0, dimension:'combustivel'}, \n            {value:600,   id:'0', category:0, dimension:'combustivel'}]\n    ]\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    definition,\n    data\n});\n\n\n//# sourceURL=webpack:///./test/data2.js?");

/***/ }),

/***/ "./test/index.js":
/*!***********************!*\
  !*** ./test/index.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src */ \"./src/index.js\");\n/* harmony import */ var _src_plugins_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/plugins/table */ \"./src/plugins/table.js\");\n/* harmony import */ var _src_adapters_elasticsearch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/adapters/elasticsearch */ \"./src/adapters/elasticsearch.js\");\n/* harmony import */ var _data2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data2 */ \"./test/data2.js\");\n// @ts-check\n\n\n\n\n\n\nlet definition = {\n    rows: {\n        'dm_dimension1': {type:'dimension'}\n    },\n    cols: {\n        'dm_dimension2': {type:'dimension'},\n        'measure1':  {type:'measure'}\n    }\n}\n\n// instance\nlet cube = new _src__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    definition: _data2__WEBPACK_IMPORTED_MODULE_3__[\"default\"].definition,\n    // dataAdapter: elastic\n})\n\n// add operations\ncube.addOperation('op1', 'totalRow', {label:'Total'})\ncube.addOperation('op2', 'totalCol', {label:'Total'})\n\ncube.setData(_data2__WEBPACK_IMPORTED_MODULE_3__[\"default\"].data)\n\nObject(_src_plugins_table__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(cube, document.getElementById('chart'))\n\n//# sourceURL=webpack:///./test/index.js?");

/***/ })

/******/ });